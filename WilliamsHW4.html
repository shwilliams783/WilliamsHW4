<!DOCTYPE html>
<!-- Stetson H Williams,
	 21 September 2017
	 Partners:	Westley Shiflet (HW2)
				Victoria Miltcheva (HW3 & HW4)
				Brandon Bocek (HW4)
				Jacob Li (HW4)
				
     This program, HW4, simulates the movement a red marker and a blue marker on 10 x 10 grid,
	 collecting data on game results over 1000000 iterations. Additionally, the game will
	 compare results between datasets from normal rules, board-wrapping rules, and
	 smart-movement rules. The data comparison will be represented graphically when the
	 tests are complete.
	 
     Inputs:
		None
     Outputs: 
		Visual display of the game state after each marker moves from start to finish
     	The number of moves taken by each marker
        The final position of each marker
     	The result of the game (red wins! / blue wins! / out of moves!)
        The maximum and minimum number of touches for any single cell
        The average number of touches across all cells
		The total number of times each marker was sent home
     Bugs to be fixed:
     	Incrementation after setTimeout() is by 2 instead of by 1
        	-May result in missed victory conditions
            -Moves look erratic, but stay within the bounds of the grid
        calcMin() not working properly
        	-Final result must either be 0 or 1
            	-0 if any tiles were never visited before a win condition
                -1 if all tiles were visited at least once before the final tile
        "Play the Game!" button rapidly increases the speed of the game
        	(reduces the timeout duration)
            -May cause missed victory conditions
     GitHub Repository: https://github.com/shwilliams783/WilliamsHW4
-->
<html>
<style>
table{
	border: 2px solid black;;
}

tr, td, th{
	border: 1px solid black;
}

table{
width:80%;
}

td{
width:25%;
}
</style>
<body>

<h1 align="center">Grid Game Simulation</h1>

<p>This program simulates a grid-based board game where two opposing pieces (red and blue)
start in opposing corners and randomly move around the board in lateral directions until
one or the other piece reaches the corner opposite from where it started, or 1 million moves have occurred.
Any time a piece lands on its opponent, the opposing piece immediately returns to its starting space.
Once the game ends, a winner (or lose condition) is determined, and game statistics are displayed.</p>
<div align="center" >
	<button onClick="playGame()">Play the Game!</button>
</div>

<table align="center">
	<tr>
		<th></th>
		<th>Normal Game</th>
		<th>Board Wrap Game</th>
		<th>Smart Move Game</th>
	</tr>
	<tr>
		<th id="redWins"></th>
		<td id="normRedWins"></td>
		<td id="wrapRedWins"></td>
		<td id="smartRedWins"></td>
	</tr>
	<tr>
		<th id="blueWins"></th>
		<td id="normBlueWins"></td>
		<td id="wrapBlueWins"></td>
		<td id="smartBlueWins"></td>
	</tr>
	<tr>
		<th id="redMoves"></th>
		<td id="normRedMoves"></td>
		<td id="wrapRedMoves"></td>
		<td id="smartRedMoves"></td>
	</tr>
	<tr>
		<th id="blueMoves"></th>
		<td id="normBlueMoves"></td>
		<td id="wrapBlueMoves"></td>
		<td id="smartBlueMoves"></td>
	</tr>
	<tr>
		<th id="redAvg"></th>
		<td id="normRedAvg"></td>
		<td id="wrapRedAvg"></td>
		<td id="smartRedAvg"></td>
	</tr>
	<tr>
		<th id="blueAvg"></th>
		<td id="normBlueAvg"></td>
		<td id="wrapBlueAvg"></td>
		<td id="smartBlueAvg"></td>
	</tr>
</table>
	
<script>

// Global Statistical Variables
var wins = 0;
var wrapWins = 0;
var normRedWins = 0;
var normBlueWins = 0;
var normRedMoves = 0;
var normBlueMoves = 0;
var normRedMoveAvg = 0;
var normBlueMoveAvg = 0
var normDraws = 0;
var wrapRedWins = 0;
var wrapBlueWins = 0;
var wrapRedMoves = 0;
var wrapBlueMoves = 0;
var wrapRedMoveAvg = 0;
var wrapBlueMoveAvg = 0
var wrapDraws = 0;
var smartRedWins = 0;
var smartBlueWins = 0;
var smartRedMoves = 0;
var smartBlueMoves = 0;
var smartRedMoveAvg = 0;
var smartBlueMoveAvg = 0
var smartDraws = 0;
var normRedMoveArray = [];
var normBlueMoveArray = [];
var wrapRedMoveArray = [];
var wrapBlueMoveArray = [];
var smartRedMoveArray = [];
var smartBlueMoveArray = [];


// Variables
var numRows = 10;
var numCols = 10;
var runSpeed = 250;

// Current coordinates of the red marker; one of these values will
// change by an integer from [-2,2] each cycle (most commonly 0).
var redPosX = 0;
var redPosY = numRows-1;

// Current coordinates of the blue marker; one of these values will
// change by an integer from [-2,2] each cycle (most commonly 0).
var bluePosX = numCols-1;
var bluePosY = 0;


// Total number of total moves, red moves, and blue moves taken; will increment by +1 each cycle or colored cycle.
var count = 0;
var redCount = 0;
var blueCount = 0;

// Total number of times red has sent blue back home, and vice versa
var redStomp = 0;
var blueStomp = 0;

// Starting grid touch counts; one cell will increment by +1 each cycle.
var grid =	[
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
			]
			
// The current maximum number of times any given cell in the grid has been touched.
var max = 0;

// The current minimum number of times any given cell in the grid has been touched.
var min = 1000000;

// The average number of times any given cell in the grid has been touched;
// to be calculated after a non-zero number of cycles have been completed.
var average = 0;

// A variable for movement directions.
var direction = 0;

// Avariable for movement distances.
var distance = 0;
//End Variables

// Functions
// playGame()
// Purpose: To simulate a starange game with a graphical display and user input
// Inputs: rowSelect, colSelect
// Outputs: The simulated strange game as descibed in HW1
function playGame(){
// Reset the game
resetAll();

// Program execution loop; This loop should loop a maximum of 1,000,000 times
// before terminating. Either the marker will reach (numRows-1, numCols-1), or the count will reach
// 1000001.
winCondition();
resetGame();
wrapWinCondition();
resetGame();

// Display the results of the simulation
updateResults();
console.log("Red Moves:");
console.log(normRedMoveArray);
console.log("Blue Moves:");
console.log(normBlueMoveArray);

}// End playGame()

function winCondition(){
	while(wins < 1000){
		moveRedMarker();
		if(redPosX == numCols-1 && redPosY == 0){
			normRedWins++;
			normRedMoves += redCount;
			normRedMoveArray.push(redCount);
			wins++;
			resetGame();
			//console.log("Red Wins!");
			continue;
		}
		moveBlueMarker();
		if(bluePosX == 0 && bluePosY == numCols-1){
			normBlueWins++;
			normBlueMoves += blueCount;
			normBlueMoveArray.push(blueCount);
			wins++;
			resetGame();
			//console.log("Blue Wins!");
			continue;
		}
	}
}

function wrapWinCondition(){
	while(wrapWins < 1000){
		wrapMoveRedMarker();
		if(redPosX == numCols-1 && redPosY == 0){
			wrapRedWins++;
			wrapRedMoves += redCount;
			wrapRedMoveArray.push(redCount);
			wrapWins++;
			resetGame();
			//console.log("Red Wins!");
			continue;
		}
		wrapMoveBlueMarker();
		if(bluePosX == 0 && bluePosY == numCols-1){
			wrapBlueWins++;
			wrapBlueMoves += blueCount;
			wrapBlueMoveArray.push(blueCount);
			wrapWins++;
			resetGame();
			//console.log("Blue Wins!");
			continue;
		}
	}
}

// moveRedMarker()
// Purpose: Simulates random movement of the red marker on the grid.
// Calls updateBoard() to update the game state in perceivable time.
// Inputs: none
// Outputs: none
function moveRedMarker(){
	
	 // Increment the counters
    count++;
	redCount++;
	
    // STEP 1: Randomly assign 0, 1, 2, or 3 to direction; these will correspond to
	// up, down, right, or left movement.
	direction = Math.floor((Math.random()*4));
	
	// STEP 2: Randomly assign 0, 1, or 2 steps to distance.
	distance = Math.floor((Math.random()*3));
	
	// STEP 3: Attempt to move the marker that direction and distance within the grid
	// If the new position would be invalid, do not move the marker.
	switch (direction)
	{
		case 0: // up
			if(redPosY + distance < numRows)
			{
				redPosY += distance; // STEP 4: Move the marker to the new position.
			}
			break;
		case 1: // down
			if(redPosY - distance >= 0)
			{
				redPosY -= distance; // STEP 4: Move the marker to the new position.
			}
			break;
		case 2: // right
			if(redPosX + distance < numCols)
			{
				redPosX += distance; // STEP 4: Move the marker to the new position.
			}
			break;
		case 3: // left
			if(redPosX - distance >= 0)
			{
				redPosX -= distance; // STEP 4: Move the marker to the new position.
			}
			break;
		default:
			break;
	}
	
	// Increment the touch count at the marker's current position on the grid.
	grid[redPosX][redPosY]++;
	
	// Check if red has stomped on blue, sending it back to start and incrementing the stomp count.
	if(redPosX == bluePosX && redPosY == bluePosY){
		redStomp++;
		goHomeBlue();
	}
	
}// End moveRedMarker()

function wrapMoveRedMarker(){
	
	// Increment the counters
    count++;
	redCount++;
	
    // STEP 1: Randomly assign 0, 1, 2, or 3 to direction; these will correspond to
	// up, down, right, or left movement.
	direction = Math.floor((Math.random()*4));
	
	// STEP 2: Randomly assign 0, 1, or 2 steps to distance.
	distance = Math.floor((Math.random()*3));
	
	// STEP 3: Attempt to move the marker that direction and distance within the grid
	// If the new position would be invalid, do not move the marker.
	switch (direction)
	{
		case 0: // up
			if(redPosY + distance < numRows)
			{
				redPosY += distance; // STEP 4: Move the marker to the new position.
			}
			else if(redPosY + distance == numRows)
			{
				redPosY = 0;
			}
			else if(redPosY + distance > numRows)
			{
				redPosY = 1;
			}
			break;
		case 1: // down
			if(redPosY - distance >= 0)
			{
				redPosY -= distance; // STEP 4: Move the marker to the new position.
			}
			else if(redPosY - distance == -1)
			{
				redPosY = numRows-1;
			}
			else if (redPosY - distance == -2)
			{
				redPosY = numRows-2;
			}
			break;
		case 2: // right
			if(redPosX + distance < numCols)
			{
				redPosX += distance; // STEP 4: Move the marker to the new position.
			}
			else if(redPosX + distance == numCols)
			{
				redPosX = 0;
			}
			else if(redPosX + distance > numCols)
			{
				redPosX = 1;
			}
			break;
		case 3: // left
			if(redPosX - distance >= 0)
			{
				redPosX -= distance; // STEP 4: Move the marker to the new position.
			}
			else if(redPosX - distance == -1)
			{
				redPosX = numCols-1;
			}
			else if(redPosX - distance == -2)
			{
				redPosX = numCols-2;
			}
			break;
		default:
			break;
	}
	
	// Increment the touch count at the marker's current position on the grid.
	grid[redPosX][redPosY]++;
	
	// Check if red has stomped on blue, sending it back to start and incrementing the stomp count.
	if(redPosX == bluePosX && redPosY == bluePosY){
		redStomp++;
		goHomeBlue();
	}
	
}

// moveBlueMarker()
// Purpose: Simulates random movement of the blue marker on the grid.
// Calls updateBoard() to update the game state in perceivable time.
// Inputs: none
// Outputs: none
function moveBlueMarker(){
	
	// Increment the counters
    count++;
	blueCount++;
	
    // STEP 1: Randomly assign 0, 1, 2, or 3 to direction; these will correspond to
	// up, down, right, or left movement.
	direction = Math.floor((Math.random()*4));
	
	// STEP 2: Randomly assign 0, 1, or 2 steps to distance.
	distance = Math.floor((Math.random()*3));
	
	// STEP 3: Attempt to move the marker that direction and distance within the grid
	// If the new position would be invalid, do not move the marker.
	switch (direction)
	{
		case 0: // up
			if(bluePosY + distance < numRows)
			{
				bluePosY += distance; // STEP 4: Move the marker to the new position.
			}
			break;
		case 1: // down
			if(bluePosY - distance >= 0)
			{
				bluePosY -= distance; // STEP 4: Move the marker to the new position.
			}
			break;
		case 2: // right
			if(bluePosX + distance < numCols)
			{
				bluePosX += distance; // STEP 4: Move the marker to the new position.
			}
			break;
		case 3: // left
			if(bluePosX - distance >= 0)
			{
				bluePosX -= distance; // STEP 4: Move the marker to the new position.
			}
			break;
		default:
			break;
	}
	
	// Increment the touch count at the marker's current position on the grid.
	grid[bluePosX][bluePosY]++;
	
	// Check if blue has stomped on red, sending it back to start and incrementing the stomp count.
	if(redPosX == bluePosX && redPosY == bluePosY){
		blueStomp++;
		goHomeRed();
	}
    
}// End moveBlueMarker()

function wrapMoveBlueMarker(){
	
	// Increment the counters
    count++;
	blueCount++;
	
    // STEP 1: Randomly assign 0, 1, 2, or 3 to direction; these will correspond to
	// up, down, right, or left movement.
	direction = Math.floor((Math.random()*4));
	
	// STEP 2: Randomly assign 0, 1, or 2 steps to distance.
	distance = Math.floor((Math.random()*3));
	
	// STEP 3: Attempt to move the marker that direction and distance within the grid
	// If the new position would be invalid, do not move the marker.
	switch (direction)
	{
		case 0: // up
			if(bluePosY + distance < numRows)
			{
				bluePosY += distance; // STEP 4: Move the marker to the new position.
			}
			else if(bluePosY + distance == numRows)
			{
				bluePosY = 0;
			}
			else if(bluePosY + distance > numRows)
			{
				bluePosY = 1;
			}
			break;
		case 1: // down
			if(bluePosY - distance >= 0)
			{
				bluePosY -= distance; // STEP 4: Move the marker to the new position.
			}
			else if(bluePosY - distance == -1)
			{
				bluePosY = numRows-1;
			}
			else if (bluePosY - distance == -2)
			{
				bluePosY = numRows-2;
			}
			break;
		case 2: // right
			if(bluePosX + distance < numCols)
			{
				bluePosX += distance; // STEP 4: Move the marker to the new position.
			}
			else if(bluePosX + distance == numCols)
			{
				bluePosX = 0;
			}
			else if(bluePosX + distance > numCols)
			{
				bluePosX = 1;
			}
			break;
		case 3: // left
			if(bluePosX - distance >= 0)
			{
				bluePosX -= distance; // STEP 4: Move the marker to the new position.
			}
			else if(bluePosX - distance == -1)
			{
				bluePosX = numCols-1;
			}
			else if(bluePosX - distance == -2)
			{
				bluePosX = numCols-2;
			}
			break;
		default:
			break;
	}
	
	// Increment the touch count at the marker's current position on the grid.
	grid[bluePosX][bluePosY]++;
	
	// Check if blue has stomped on red, sending it back to start and incrementing the stomp count.
	if(redPosX == bluePosX && redPosY == bluePosY){
		blueStomp++;
		goHomeRed();
	}
	
}

// updateResults()
// Purpose: graphically updates the UI in real time
// Inputs: none
// Outputs: none
function updateResults(){
	
// Display the number of moves taken by the red marker during this game.
document.getElementById("redWins").innerHTML = "Red Wins";
document.getElementById("normRedWins").innerHTML = normRedWins;
document.getElementById("wrapRedWins").innerHTML = wrapRedWins;
document.getElementById("smartRedWins").innerHTML = smartRedWins;

// Display the number of moves taken by the blue marker during this game.
document.getElementById("blueWins").innerHTML = "Blue Wins";
document.getElementById("normBlueWins").innerHTML = normBlueWins;
document.getElementById("wrapBlueWins").innerHTML = wrapBlueWins;
document.getElementById("smartBlueWins").innerHTML = smartBlueWins;

// Display the number of moves taken by the red marker during each red victory.
document.getElementById("redMoves").innerHTML = "Total Red Victory Moves";
document.getElementById("normRedMoves").innerHTML = normRedMoves;
document.getElementById("wrapRedMoves").innerHTML = wrapRedMoves;
document.getElementById("smartRedMoves").innerHTML = smartRedMoves;

// Display the number of moves taken by the blue marker during each blue victory.
document.getElementById("blueMoves").innerHTML = "Total Blue Victory Moves";
document.getElementById("normBlueMoves").innerHTML = normBlueMoves;
document.getElementById("wrapBlueMoves").innerHTML = wrapBlueMoves;
document.getElementById("smartBlueMoves").innerHTML = smartBlueMoves;

// Display the average number of moves taken by the red marker resulting in a red victory.
normRedMoveAvg = normRedMoves/normRedWins;
wrapRedMoveAvg = wrapRedMoves/wrapRedWins;
document.getElementById("redAvg").innerHTML = "Average Moves Per Red Victory";
document.getElementById("normRedAvg").innerHTML = (normRedMoveAvg).toFixed(2);
document.getElementById("wrapRedAvg").innerHTML = (wrapRedMoveAvg).toFixed(2);
document.getElementById("smartRedAvg").innerHTML = (smartRedMoveAvg).toFixed(2);

// Display the average number of moves taken by the blue marker resulting in a blue victory.
normBlueMoveAvg = normBlueMoves/normBlueWins;
wrapBlueMoveAvg = wrapBlueMoves/wrapBlueWins;
document.getElementById("blueAvg").innerHTML = "Average Moves Per Blue Victory";
document.getElementById("normBlueAvg").innerHTML = (normBlueMoveAvg).toFixed(2);
document.getElementById("wrapBlueAvg").innerHTML = (wrapBlueMoveAvg).toFixed(2);
document.getElementById("smartBlueAvg").innerHTML = (smartBlueMoveAvg).toFixed(2);


}// End updateResults()

// resetGame()
// Purpose: This function resets the starting variables to their default values
// Inputs: none
// Outputs: none
function resetGame(){
numRows = 10;
numCols = 10;
runSpeed = 250;
redPosX = 0;
redPosY = numRows-1;
bluePosX = numCols-1;
bluePosY = 0;
count = 0;
redCount = 0;
blueCount = 0;
redStomp = 0;
blueStomp = 0;
grid =	[
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
		]
max = 0;
min = 1000000;
average = 0;
direction = 0;
distance = 0;
}// End resetGame()

function resetAll(){

resetGame();

// Global Statistical Variables
wins = 0;
wrapWins = 0;
normRedWins = 0;
normBlueWins = 0;
normRedMoves = 0;
normBlueMoves = 0;
normRedMoveAvg = 0;
normBlueMoveAvg = 0
normDraws = 0;
wrapRedWins = 0;
wrapBlueWins = 0;
wrapRedMoves = 0;
wrapBlueMoves = 0;
wrapRedMoveAvg = 0;
wrapBlueMoveAvg = 0
wrapDraws = 0;
smartRedWins = 0;
smartBlueWins = 0;
smartRedMoves = 0;
smartBlueMoves = 0;
smartRedMoveAvg = 0;
smartBlueMoveAvg = 0
smartDraws = 0;
normRedMoveArray = [];
normBlueMoveArray = [];
wrapRedMoveArray = [];
wrapBlueMoveArray = [];
smartRedMoveArray = [];
smartBlueMoveArray = [];

}

// goHomeRed()
// Purpose: This function moves the red marker back to (0,numRows-1).
// 			This function is to be called when the blue marker	
//			ends its move on the red marker, sending it back to start.
// Inputs: none
// Outputs: none
function goHomeRed(){
	redPosX = 0;
	redPosY = numRows-1;
}// End goHomeRed()

// goHomeRed()
// Purpose: This function moves the blue marker back to (numCols-1,0).
// 			This function is to be called when the red marker	
//			ends its move on the blue marker, sending it back to start.
// Inputs: none
// Outputs: none
function goHomeBlue(){
	bluePosX = numCols-1;
	bluePosY = 0;
}// End goHomeBlue()

</script>

</body>
</html>

<!DOCTYPE html>
<!-- Stetson H Williams,
	 21 September 2017
	 Partners:	Westley Shiflet (HW2)
				Victoria Miltcheva (HW3 & HW4)
				Brandon Bocek (HW4)
				Jacob Li (HW4)
				
     This program, HW4, simulates the movement a red marker and a blue marker on 10 x 10 grid,
	 collecting data on game results over 1000000 iterations. Additionally, the game will
	 compare results between datasets from normal rules, board-wrapping rules, and
	 smart-movement rules. The data comparison will be represented graphically when the
	 tests are complete.
	 
     Inputs:
		None
     Outputs: 
		Visual display of the game state after each marker moves from start to finish
     	The number of moves taken by each marker
        The final position of each marker
     	The result of the game (red wins! / blue wins! / out of moves!)
        The maximum and minimum number of touches for any single cell
        The average number of touches across all cells
		The total number of times each marker was sent home
     Bugs to be fixed:
     	Incrementation after setTimeout() is by 2 instead of by 1
        	-May result in missed victory conditions
            -Moves look erratic, but stay within the bounds of the grid
        calcMin() not working properly
        	-Final result must either be 0 or 1
            	-0 if any tiles were never visited before a win condition
                -1 if all tiles were visited at least once before the final tile
        "Play the Game!" button rapidly increases the speed of the game
        	(reduces the timeout duration)
            -May cause missed victory conditions
     GitHub Repository: https://github.com/shwilliams783/WilliamsHW4
-->
<html>
<body>

<h1>Grid Game Simulation</h1>

<p>This program simulates a grid-based board game where two opposing pieces (red and blue)
start in opposing corners and randomly move around the board in lateral directions until
one or the other piece reaches the corner opposite from where it started, or 1 million moves have occurred.
Any time a piece lands on its opponent, the opposing piece immediately returns to its starting space.
Once the game ends, a winner (or lose condition) is determined, and game statistics are displayed.</p>

<button onClick="playGame()">Play the Game!</button>
<p id="redWins"></p>
<p id="blueWins"></p>
<p id="redMoves"></p>
<p id="blueMoves"></p>
<p id="redAvg"></p>
<p id="blueAvg"></p>

<script>

// Global Statistical Variables
var wins = 0;
var normRedWins = 0;
var normBlueWins = 0;
var normRedMoves = 0;
var normBlueMoves = 0;
var normRedMoveAvg = 0;
var normBlueMoveAvg = 0
var normDraws = 0;
var wrapRedWins = 0;
var wrapBlueWins = 0;
var wrapRedMoves = 0;
var wrapBlueMoves = 0;
var wrapRedMoveAvg = 0;
var wrapBlueMoveAvg = 0
var wrapDraws = 0;
var smartRedWins = 0;
var smartBlueWins = 0;
var smartRedMoves = 0;
var smartBlueMoves = 0;
var smartRedMoveAvg = 0;
var smartBlueMoveAvg = 0
var smartDraws = 0;

// Variables
var numRows = 10;
var numCols = 10;
var runSpeed = 250;

// Current coordinates of the red marker; one of these values will
// change by an integer from [-2,2] each cycle (most commonly 0).
var redPosX = 0;
var redPosY = numRows-1;

// Current coordinates of the blue marker; one of these values will
// change by an integer from [-2,2] each cycle (most commonly 0).
var bluePosX = numCols-1;
var bluePosY = 0;


// Total number of total moves, red moves, and blue moves taken; will increment by +1 each cycle or colored cycle.
var count = 0;
var redCount = 0;
var blueCount = 0;

// Total number of times red has sent blue back home, and vice versa
var redStomp = 0;
var blueStomp = 0;

// Starting grid touch counts; one cell will increment by +1 each cycle.
var grid =	[
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
			]
			
// The current maximum number of times any given cell in the grid has been touched.
var max = 0;

// The current minimum number of times any given cell in the grid has been touched.
var min = 1000000;

// The average number of times any given cell in the grid has been touched;
// to be calculated after a non-zero number of cycles have been completed.
var average = 0;

// A variable for movement directions.
var direction = 0;

// Avariable for movement distances.
var distance = 0;
//End Variables

// Functions
// playGame()
// Purpose: To simulate a starange game with a graphical display and user input
// Inputs: rowSelect, colSelect
// Outputs: The simulated strange game as descibed in HW1
function playGame(){
// Reset the game
resetAll();

// Program execution loop; This loop should loop a maximum of 1,000,000 times
// before terminating. Either the marker will reach (numRows-1, numCols-1), or the count will reach
// 1000001.
winCondition();

// Display the results of the simulation
updateResults();

}// End playGame()

function winCondition(){
	while(wins < 1000){
		moveRedMarker();
		if(redPosX == numCols-1 && redPosY == 0){
			normRedWins++;
			normRedMoves += redCount;
			wins++;
			resetGame();
			//console.log("Red Wins!");
			continue;
		}
		moveBlueMarker();
		if(bluePosX == 0 && bluePosY == numCols-1){
			normBlueWins++;
			normBlueMoves += blueCount;
			wins++;
			resetGame();
			//console.log("Blue Wins!");
			continue;
		}
	}
}

// moveRedMarker()
// Purpose: Simulates random movement of the red marker on the grid.
// Calls updateBoard() to update the game state in perceivable time.
// Inputs: none
// Outputs: none
function moveRedMarker(){
	
	 // Increment the counters
    count++;
	redCount++;
	
    // STEP 1: Randomly assign 0, 1, 2, or 3 to direction; these will correspond to
	// up, down, right, or left movement.
	direction = Math.floor((Math.random()*4));
	
	// STEP 2: Randomly assign 0, 1, or 2 steps to distance.
	distance = Math.floor((Math.random()*3));
	
	// STEP 3: Attempt to move the marker that direction and distance within the grid
	// If the new position would be invalid, do not move the marker.
	switch (direction)
	{
		case 0: // up
			if(redPosY + distance < numRows)
			{
				redPosY += distance; // STEP 4: Move the marker to the new position.
			}
			break;
		case 1: // down
			if(redPosY - distance >= 0)
			{
				redPosY -= distance; // STEP 4: Move the marker to the new position.
			}
			break;
		case 2: // right
			if(redPosX + distance < numCols)
			{
				redPosX += distance; // STEP 4: Move the marker to the new position.
			}
			break;
		case 3: // left
			if(redPosX - distance >= 0)
			{
				redPosX -= distance; // STEP 4: Move the marker to the new position.
			}
			break;
		default:
			break;
	}
	
	// Increment the touch count at the marker's current position on the grid.
	grid[redPosX][redPosY]++;
	
	// Check if red has stomped on blue, sending it back to start and incrementing the stomp count.
	if(redPosX == bluePosX && redPosY == bluePosY){
		redStomp++;
		goHomeBlue();
	}
	
}// End moveRedMarker()

// moveBlueMarker()
// Purpose: Simulates random movement of the blue marker on the grid.
// Calls updateBoard() to update the game state in perceivable time.
// Inputs: none
// Outputs: none
function moveBlueMarker(){
	
	// Increment the counters
    count++;
	blueCount++;
	
    // STEP 1: Randomly assign 0, 1, 2, or 3 to direction; these will correspond to
	// up, down, right, or left movement.
	direction = Math.floor((Math.random()*4));
	
	// STEP 2: Randomly assign 0, 1, or 2 steps to distance.
	distance = Math.floor((Math.random()*3));
	
	// STEP 3: Attempt to move the marker that direction and distance within the grid
	// If the new position would be invalid, do not move the marker.
	switch (direction)
	{
		case 0: // up
			if(bluePosY + distance < numRows)
			{
				bluePosY += distance; // STEP 4: Move the marker to the new position.
			}
			break;
		case 1: // down
			if(bluePosY - distance >= 0)
			{
				bluePosY -= distance; // STEP 4: Move the marker to the new position.
			}
			break;
		case 2: // right
			if(bluePosX + distance < numCols)
			{
				bluePosX += distance; // STEP 4: Move the marker to the new position.
			}
			break;
		case 3: // left
			if(bluePosX - distance >= 0)
			{
				bluePosX -= distance; // STEP 4: Move the marker to the new position.
			}
			break;
		default:
			break;
	}
	
	// Increment the touch count at the marker's current position on the grid.
	grid[bluePosX][bluePosY]++;
	
	// Check if blue has stomped on red, sending it back to start and incrementing the stomp count.
	if(redPosX == bluePosX && redPosY == bluePosY){
		blueStomp++;
		goHomeRed();
	}
    
}// End moveBlueMarker()

// updateResults()
// Purpose: graphically updates the UI in real time
// Inputs: none
// Outputs: none
function updateResults(){
	
// Display the number of moves taken by the red marker during this game.
document.getElementById("redWins").innerHTML = "Number of times Red has won: " + normRedWins;

// Display the number of moves taken by the blue marker during this game.
document.getElementById("blueWins").innerHTML = "Number of times Blue has won: " + normBlueWins;

// Display the number of moves taken by the red marker during each red victory.
document.getElementById("redMoves").innerHTML = "Number of times Red has moved per Red victory: " + normRedMoves;

// Display the number of moves taken by the blue marker during each blue victory.
document.getElementById("blueMoves").innerHTML = "Number of times Blue has moved per Blue victory: " + normBlueMoves;

// Display the average number of moves taken by the red marker resulting in a red victory.
normRedMoveAvg = normRedMoves/normRedWins;
document.getElementById("redAvg").innerHTML = "Number of times Red has moved on average per Red victory: " + normRedMoveAvg;

// Display the average number of moves taken by the blue marker resulting in a blue victory.
normBlueMoveAvg = normBlueMoves/normBlueWins;
document.getElementById("blueAvg").innerHTML = "Number of times Blue has moved on average per Blue victory: " + normBlueMoveAvg;

}// End updateResults()

// resetGame()
// Purpose: This function resets the starting variables to their default values
// Inputs: none
// Outputs: none
function resetGame(){
numRows = 10;
numCols = 10;
runSpeed = 250;
redPosX = 0;
redPosY = numRows-1;
bluePosX = numCols-1;
bluePosY = 0;
count = 0;
redCount = 0;
blueCount = 0;
redStomp = 0;
blueStomp = 0;
grid =	[
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
		]
max = 0;
min = 1000000;
average = 0;
direction = 0;
distance = 0;
}// End resetGame()

function resetAll(){

resetGame();

// Global Statistical Variables
wins = 0;
normRedWins = 0;
normBlueWins = 0;
normRedMoves = 0;
normBlueMoves = 0;
normRedMoveAvg = 0;
normBlueMoveAvg = 0
normDraws = 0;
wrapRedWins = 0;
wrapBlueWins = 0;
wrapRedMoves = 0;
wrapBlueMoves = 0;
wrapRedMoveAvg = 0;
wrapBlueMoveAvg = 0
wrapDraws = 0;
smartRedWins = 0;
smartBlueWins = 0;
smartRedMoves = 0;
smartBlueMoves = 0;
smartRedMoveAvg = 0;
smartBlueMoveAvg = 0
smartDraws = 0;

}

// calcMax()
// Purpose: This function calculates the maximum number of times any given tile was touched.
// Inputs: none
// Outputs: none
function calcMax(){
	for(i = 0; i < numCols; i++){
		for(j = 0; j < numRows; j++){
			
	
			// Check for touch counts higher than the current max.
			if(grid[i][j] > max)
			{
				max = grid[i][j];
				
			}
		}
	}
}// End calcMax()

// calcMin()
// Purpose: This function calculates the minimum number of times any given tile was touched.
// Inputs: none
// Outputs: none
function calcMin(){
	for(i = 0; i < numCols; i++){
		for(j = 0; j < numRows; j++){
			
			// Check for touch counts lower than the current min.
			if(grid[i][j] < min)
			{
				min = grid[i][j];
			}
		}
	}
}// End calcMin()

// goHomeRed()
// Purpose: This function moves the red marker back to (0,numRows-1).
// 			This function is to be called when the blue marker	
//			ends its move on the red marker, sending it back to start.
// Inputs: none
// Outputs: none
function goHomeRed(){
	redPosX = 0;
	redPosY = numRows-1;
}// End goHomeRed()

// goHomeRed()
// Purpose: This function moves the blue marker back to (numCols-1,0).
// 			This function is to be called when the red marker	
//			ends its move on the blue marker, sending it back to start.
// Inputs: none
// Outputs: none
function goHomeBlue(){
	bluePosX = numCols-1;
	bluePosY = 0;
}// End goHomeBlue()

</script>

</body>
</html>

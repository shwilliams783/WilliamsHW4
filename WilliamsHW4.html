<!DOCTYPE html>
<!-- Stetson H Williams,
	 21 September 2017
	 Partners:	Westley Shiflet (HW2)
				Victoria Miltcheva (HW3 & HW4)
				Brandon Bocek (HW4)
				Jacob Li (HW4)
				
     This program, HW4, simulates the movement a red marker and a blue marker on 10 x 10 grid,
	 collecting data on game results over 1000000 iterations. Additionally, the game will
	 compare results between datasets from normal rules, board-wrapping rules, and
	 smart-movement rules. The data comparison will be represented graphically when the
	 tests are complete.
	 
     Inputs:
		None
     Outputs: 
		Visual display of the game state after each marker moves from start to finish
     	The number of moves taken by each marker
        The final position of each marker
     	The result of the game (red wins! / blue wins! / out of moves!)
        The maximum and minimum number of touches for any single cell
        The average number of touches across all cells
		The total number of times each marker was sent home
     Bugs to be fixed:
     	Incrementation after setTimeout() is by 2 instead of by 1
        	-May result in missed victory conditions
            -Moves look erratic, but stay within the bounds of the grid
        calcMin() not working properly
        	-Final result must either be 0 or 1
            	-0 if any tiles were never visited before a win condition
                -1 if all tiles were visited at least once before the final tile
        "Play the Game!" button rapidly increases the speed of the game
        	(reduces the timeout duration)
            -May cause missed victory conditions
     GitHub Repository: https://github.com/shwilliams783/WilliamsHW4
-->
<html>
<header>
	<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
</header>
<style>
table{
	border: 2px solid black;;
}

tr, td, th{
	border: 1px solid black;
}

table{
width:80%;
}

td{
width:25%;
}
</style>
<body>

<h1 align="center">Grid Game Simulation</h1>

<p>This program simulates a grid-based board game where two opposing pieces (red and blue)
start in opposing corners and randomly move around the board in lateral directions until
one or the other piece reaches the corner opposite from where it started, or 1 million moves have occurred.
Any time a piece lands on its opponent, the opposing piece immediately returns to its starting space.
Once the game ends, a winner (or lose condition) is determined, and game statistics are displayed.</p>
<div align="center" >
	<button onClick="playGame()">Play the Game!</button>
	<div id="chart_div"></div>
</div>

<table align="center" id="resultTable">
	<tr>
		<th></th>
		<th>Normal Game</th>
		<th>Board Wrap Game</th>
		<th>Smart Move Game</th>
	</tr>
	<tr>
		<th id="redWins"></th>
		<td id="normRedWins"></td>
		<td id="wrapRedWins"></td>
		<td id="smartRedWins"></td>
	</tr>
	<tr>
		<th id="blueWins"></th>
		<td id="normBlueWins"></td>
		<td id="wrapBlueWins"></td>
		<td id="smartBlueWins"></td>
	</tr>
	<tr>
		<th id="redMoves"></th>
		<td id="normRedMoves"></td>
		<td id="wrapRedMoves"></td>
		<td id="smartRedMoves"></td>
	</tr>
	<tr>
		<th id="blueMoves"></th>
		<td id="normBlueMoves"></td>
		<td id="wrapBlueMoves"></td>
		<td id="smartBlueMoves"></td>
	</tr>
	<tr>
		<th id="redAvg"></th>
		<td id="normRedAvg"></td>
		<td id="wrapRedAvg"></td>
		<td id="smartRedAvg"></td>
	</tr>
	<tr>
		<th id="blueAvg"></th>
		<td id="normBlueAvg"></td>
		<td id="wrapBlueAvg"></td>
		<td id="smartBlueAvg"></td>
	</tr>
</table>
	
<script>
// Hide the Results Table
document.getElementById("resultTable").style.display="none";

google.charts.load('current', {packages: ['corechart', 'bar']});
google.charts.setOnLoadCallback();

var data;
var chart;
var options;

// Global Statistical Variables
var wins = 0;
var wrapWins = 0;
var smartWins = 0;
var normRedWins = 0;
var normBlueWins = 0;
var normRedMoves = 0;
var normBlueMoves = 0;
var normRedMoveAvg = 0;
var normBlueMoveAvg = 0
var normDraws = 0;
var wrapRedWins = 0;
var wrapBlueWins = 0;
var wrapRedMoves = 0;
var wrapBlueMoves = 0;
var wrapRedMoveAvg = 0;
var wrapBlueMoveAvg = 0
var wrapDraws = 0;
var smartRedWins = 0;
var smartBlueWins = 0;
var smartRedMoves = 0;
var smartBlueMoves = 0;
var smartRedMoveAvg = 0;
var smartBlueMoveAvg = 0
var smartDraws = 0;
var normRedMoveArray = [];
var normBlueMoveArray = [];
var wrapRedMoveArray = [];
var wrapBlueMoveArray = [];
var smartRedMoveArray = [];
var smartBlueMoveArray = [];

// Game Variables
var numRows = 10;
var numCols = 10;
var runSpeed = 250;
var redPosX = 0;
var redPosY = numRows-1;
var bluePosX = numCols-1;
var bluePosY = 0;
var count = 0;
var redCount = 0;
var blueCount = 0;
var redStomp = 0;
var blueStomp = 0;
var grid =	[
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
			];
var direction = 0;
var distance = 0;
//End Variables

// Functions
/* playGame()
// Purpose: To simulate a starange game with a graphical display and user input
// Inputs: rowSelect, colSelect
// Outputs: The simulated strange game as descibed in HW1
*/
function playGame(){
// Reset the game
resetAll();

// Program execution loop; This loop should loop a maximum of 1,000,000 times
// before terminating. Either the marker will reach (numRows-1, numCols-1), or the count will reach
// 1000001.
winCondition();
resetGame();
wrapWinCondition();
resetGame();
smartWinCondition();
resetGame();

// Display the results of the simulation
updateResults();

}// End playGame()

function winCondition(){
	while(wins < 1000){
		moveRedMarker();
		if(redPosX == numCols-1 && redPosY == 0){
			normRedWins++;
			normRedMoves += redCount;
			normRedMoveArray.push(redCount);
			wins++;
			resetGame();
			continue;
		}
		moveBlueMarker();
		if(bluePosX == 0 && bluePosY == numCols-1){
			normBlueWins++;
			normBlueMoves += blueCount;
			normBlueMoveArray.push(blueCount);
			wins++;
			resetGame();
			continue;
		}
	}
}

function wrapWinCondition(){
	while(wrapWins < 1000){
		wrapMoveRedMarker();
		if(redPosX == numCols-1 && redPosY == 0){
			wrapRedWins++;
			wrapRedMoves += redCount;
			wrapRedMoveArray.push(redCount);
			wrapWins++;
			resetGame();
			continue;
		}
		wrapMoveBlueMarker();
		if(bluePosX == 0 && bluePosY == numCols-1){
			wrapBlueWins++;
			wrapBlueMoves += blueCount;
			wrapBlueMoveArray.push(blueCount);
			wrapWins++;
			resetGame();
			continue;
		}
	}
}

function smartWinCondition(){
	while(smartWins < 1000){
		smartMoveRedMarker();
		if(redPosX == numCols-1 && redPosY == 0){
			smartRedWins++;
			smartRedMoves += redCount;
			smartRedMoveArray.push(redCount);
			smartWins++;
			resetGame();
			continue;
		}
		smartMoveBlueMarker();
		if(bluePosX == 0 && bluePosY == numCols-1){
			smartBlueWins++;
			smartBlueMoves += blueCount;
			smartBlueMoveArray.push(blueCount);
			smartWins++;
			resetGame();
			continue;
		}
	}
}

/* moveRedMarker()
// Purpose: Simulates random movement of the red marker on the grid.
// Calls updateBoard() to update the game state in perceivable time.
// Inputs: none
// Outputs: none
*/
function moveRedMarker(){
	
	 // Increment the counters
    count++;
	redCount++;
	
    // STEP 1: Randomly assign 0, 1, 2, or 3 to direction; these will correspond to
	// up, down, right, or left movement.
	direction = Math.floor((Math.random()*4));
	
	// STEP 2: Randomly assign 0, 1, or 2 steps to distance.
	distance = Math.floor((Math.random()*3));
	
	// STEP 3: Attempt to move the marker that direction and distance within the grid
	// If the new position would be invalid, do not move the marker.
	switch (direction)
	{
		case 0: // down
			if(redPosY + distance < numRows)
			{
				redPosY += distance; // STEP 4: Move the marker to the new position.
			}
			break;
		case 1: // up
			if(redPosY - distance >= 0)
			{
				redPosY -= distance; // STEP 4: Move the marker to the new position.
			}
			break;
		case 2: // right
			if(redPosX + distance < numCols)
			{
				redPosX += distance; // STEP 4: Move the marker to the new position.
			}
			break;
		case 3: // left
			if(redPosX - distance >= 0)
			{
				redPosX -= distance; // STEP 4: Move the marker to the new position.
			}
			break;
		default:
			break;
	}
	
	// Increment the touch count at the marker's current position on the grid.
	grid[redPosX][redPosY]++;
	
	// Check if red has stomped on blue, sending it back to start and incrementing the stomp count.
	if(redPosX == bluePosX && redPosY == bluePosY){
		redStomp++;
		goHomeBlue();
	}
	
}// End moveRedMarker()

function wrapMoveRedMarker(){
	
	// Increment the counters
    count++;
	redCount++;
	
    // STEP 1: Randomly assign 0, 1, 2, or 3 to direction; these will correspond to
	// up, down, right, or left movement.
	direction = Math.floor((Math.random()*4));
	
	// STEP 2: Randomly assign 0, 1, or 2 steps to distance.
	distance = Math.floor((Math.random()*3));
	
	// STEP 3: Attempt to move the marker that direction and distance within the grid
	// If the new position would be invalid, do not move the marker.
	switch (direction)
	{
		case 0: // down
			if(redPosY + distance < numRows)
			{
				redPosY += distance; // STEP 4: Move the marker to the new position.
			}
			else if(redPosY + distance == numRows)
			{
				redPosY = 0;
			}
			else if(redPosY + distance > numRows)
			{
				redPosY = 1;
			}
			break;
		case 1: // up
			if(redPosY - distance >= 0)
			{
				redPosY -= distance; // STEP 4: Move the marker to the new position.
			}
			else if(redPosY - distance == -1)
			{
				redPosY = numRows-1;
			}
			else if (redPosY - distance == -2)
			{
				redPosY = numRows-2;
			}
			break;
		case 2: // right
			if(redPosX + distance < numCols)
			{
				redPosX += distance; // STEP 4: Move the marker to the new position.
			}
			else if(redPosX + distance == numCols)
			{
				redPosX = 0;
			}
			else if(redPosX + distance > numCols)
			{
				redPosX = 1;
			}
			break;
		case 3: // left
			if(redPosX - distance >= 0)
			{
				redPosX -= distance; // STEP 4: Move the marker to the new position.
			}
			else if(redPosX - distance == -1)
			{
				redPosX = numCols-1;
			}
			else if(redPosX - distance == -2)
			{
				redPosX = numCols-2;
			}
			break;
		default:
			break;
	}
	
	// Increment the touch count at the marker's current position on the grid.
	grid[redPosX][redPosY]++;
	
	// Check if red has stomped on blue, sending it back to start and incrementing the stomp count.
	if(redPosX == bluePosX && redPosY == bluePosY){
		redStomp++;
		goHomeBlue();
	}
	
}

function smartMoveRedMarker(){
	
	 // Increment the counters
    count++;
	redCount++;
	
    // STEP 1: Randomly assign 0, or 1 to direction; these will correspond to
	// up, or right movement.
	direction = Math.floor((Math.random()*2));
	
	// STEP 2: Randomly assign 0, 1, or 2 steps to distance.
	distance = Math.floor((Math.random()*3));
	
	// STEP 3: Attempt to move the marker that direction and distance within the grid
	// If the new position would be invalid, do not move the marker.
	switch (direction)
	{
		case 0: // up
			if(redPosY - distance >= 0)
			{
				redPosY -= distance; // STEP 4: Move the marker to the new position.
			}
			break;
		case 1: // right
			if(redPosX + distance < numCols)
			{
				redPosX += distance; // STEP 4: Move the marker to the new position.
			}
			break;
		default:
			break;
	}
	
	// Increment the touch count at the marker's current position on the grid.
	grid[redPosX][redPosY]++;
	
	// Check if red has stomped on blue, sending it back to start and incrementing the stomp count.
	if(redPosX == bluePosX && redPosY == bluePosY){
		redStomp++;
		goHomeBlue();
	}
	
}

/* moveBlueMarker()
// Purpose: Simulates random movement of the blue marker on the grid.
// Calls updateBoard() to update the game state in perceivable time.
// Inputs: none
// Outputs: none
*/
function moveBlueMarker(){
	
	// Increment the counters
    count++;
	blueCount++;
	
    // STEP 1: Randomly assign 0, 1, 2, or 3 to direction; these will correspond to
	// up, down, right, or left movement.
	direction = Math.floor((Math.random()*4));
	
	// STEP 2: Randomly assign 0, 1, or 2 steps to distance.
	distance = Math.floor((Math.random()*3));
	
	// STEP 3: Attempt to move the marker that direction and distance within the grid
	// If the new position would be invalid, do not move the marker.
	switch (direction)
	{
		case 0: // down
			if(bluePosY + distance < numRows)
			{
				bluePosY += distance; // STEP 4: Move the marker to the new position.
			}
			break;
		case 1: // up
			if(bluePosY - distance >= 0)
			{
				bluePosY -= distance; // STEP 4: Move the marker to the new position.
			}
			break;
		case 2: // right
			if(bluePosX + distance < numCols)
			{
				bluePosX += distance; // STEP 4: Move the marker to the new position.
			}
			break;
		case 3: // left
			if(bluePosX - distance >= 0)
			{
				bluePosX -= distance; // STEP 4: Move the marker to the new position.
			}
			break;
		default:
			break;
	}
	
	// Increment the touch count at the marker's current position on the grid.
	grid[bluePosX][bluePosY]++;
	
	// Check if blue has stomped on red, sending it back to start and incrementing the stomp count.
	if(redPosX == bluePosX && redPosY == bluePosY){
		blueStomp++;
		goHomeRed();
	}
    
}// End moveBlueMarker()

function wrapMoveBlueMarker(){
	
	// Increment the counters
    count++;
	blueCount++;
	
    // STEP 1: Randomly assign 0, 1, 2, or 3 to direction; these will correspond to
	// up, down, right, or left movement.
	direction = Math.floor((Math.random()*4));
	
	// STEP 2: Randomly assign 0, 1, or 2 steps to distance.
	distance = Math.floor((Math.random()*3));
	
	// STEP 3: Attempt to move the marker that direction and distance within the grid
	// If the new position would be invalid, do not move the marker.
	switch (direction)
	{
		case 0: // down
			if(bluePosY + distance < numRows)
			{
				bluePosY += distance; // STEP 4: Move the marker to the new position.
			}
			else if(bluePosY + distance == numRows)
			{
				bluePosY = 0;
			}
			else if(bluePosY + distance > numRows)
			{
				bluePosY = 1;
			}
			break;
		case 1: // up
			if(bluePosY - distance >= 0)
			{
				bluePosY -= distance; // STEP 4: Move the marker to the new position.
			}
			else if(bluePosY - distance == -1)
			{
				bluePosY = numRows-1;
			}
			else if (bluePosY - distance == -2)
			{
				bluePosY = numRows-2;
			}
			break;
		case 2: // right
			if(bluePosX + distance < numCols)
			{
				bluePosX += distance; // STEP 4: Move the marker to the new position.
			}
			else if(bluePosX + distance == numCols)
			{
				bluePosX = 0;
			}
			else if(bluePosX + distance > numCols)
			{
				bluePosX = 1;
			}
			break;
		case 3: // left
			if(bluePosX - distance >= 0)
			{
				bluePosX -= distance; // STEP 4: Move the marker to the new position.
			}
			else if(bluePosX - distance == -1)
			{
				bluePosX = numCols-1;
			}
			else if(bluePosX - distance == -2)
			{
				bluePosX = numCols-2;
			}
			break;
		default:
			break;
	}
	
	// Increment the touch count at the marker's current position on the grid.
	grid[bluePosX][bluePosY]++;
	
	// Check if blue has stomped on red, sending it back to start and incrementing the stomp count.
	if(redPosX == bluePosX && redPosY == bluePosY){
		blueStomp++;
		goHomeRed();
	}
	
}

function smartMoveBlueMarker(){
	
	// Increment the counters
    count++;
	blueCount++;
	
    // STEP 1: Randomly assign 0, or 1 to direction; these will correspond to
	// down, or left movement.
	direction = Math.floor((Math.random()*2));
	
	// STEP 2: Randomly assign 0, 1, or 2 steps to distance.
	distance = Math.floor((Math.random()*3));
	
	// STEP 3: Attempt to move the marker that direction and distance within the grid
	// If the new position would be invalid, do not move the marker.
	switch (direction)
	{
		case 0: // down
			if(bluePosY + distance < numCols)
			{
				bluePosY += distance; // STEP 4: Move the marker to the new position.
			}
			break;
		case 1: // left
			if(bluePosX - distance >= 0)
			{
				bluePosX -= distance; // STEP 4: Move the marker to the new position.
			}
			break;
		default:
			break;
	}
	
	// Increment the touch count at the marker's current position on the grid.
	grid[bluePosX][bluePosY]++;
	
	// Check if blue has stomped on red, sending it back to start and incrementing the stomp count.
	if(redPosX == bluePosX && redPosY == bluePosY){
		blueStomp++;
		goHomeRed();
	}
    
}// End moveBlueMarker()


/* updateResults()
// Purpose: graphically updates the UI in real time
// Inputs: none
// Outputs: none
*/
function updateResults(){

// Show the Results Table
document.getElementById("resultTable").style.display="table";	

// Display the number of moves taken by the red marker during this game.
document.getElementById("redWins").innerHTML = "Red Wins";
document.getElementById("normRedWins").innerHTML = normRedWins;
document.getElementById("wrapRedWins").innerHTML = wrapRedWins;
document.getElementById("smartRedWins").innerHTML = smartRedWins;

// Display the number of moves taken by the blue marker during this game.
document.getElementById("blueWins").innerHTML = "Blue Wins";
document.getElementById("normBlueWins").innerHTML = normBlueWins;
document.getElementById("wrapBlueWins").innerHTML = wrapBlueWins;
document.getElementById("smartBlueWins").innerHTML = smartBlueWins;

// Display the number of moves taken by the red marker during each red victory.
document.getElementById("redMoves").innerHTML = "Total Red Victory Moves";
document.getElementById("normRedMoves").innerHTML = normRedMoves;
document.getElementById("wrapRedMoves").innerHTML = wrapRedMoves;
document.getElementById("smartRedMoves").innerHTML = smartRedMoves;

// Display the number of moves taken by the blue marker during each blue victory.
document.getElementById("blueMoves").innerHTML = "Total Blue Victory Moves";
document.getElementById("normBlueMoves").innerHTML = normBlueMoves;
document.getElementById("wrapBlueMoves").innerHTML = wrapBlueMoves;
document.getElementById("smartBlueMoves").innerHTML = smartBlueMoves;

// Display the average number of moves taken by the red marker resulting in a red victory.
normRedMoveAvg = normRedMoves/normRedWins;
wrapRedMoveAvg = wrapRedMoves/wrapRedWins;
smartRedMoveAvg = smartRedMoves/smartRedWins;
document.getElementById("redAvg").innerHTML = "Average Moves Per Red Victory";
document.getElementById("normRedAvg").innerHTML = (normRedMoveAvg).toFixed(2);
document.getElementById("wrapRedAvg").innerHTML = (wrapRedMoveAvg).toFixed(2);
document.getElementById("smartRedAvg").innerHTML = (smartRedMoveAvg).toFixed(2);

// Display the average number of moves taken by the blue marker resulting in a blue victory.
normBlueMoveAvg = normBlueMoves/normBlueWins;
wrapBlueMoveAvg = wrapBlueMoves/wrapBlueWins;
smartBlueMoveAvg = smartBlueMoves/smartBlueWins;
document.getElementById("blueAvg").innerHTML = "Average Moves Per Blue Victory";
document.getElementById("normBlueAvg").innerHTML = (normBlueMoveAvg).toFixed(2);
document.getElementById("wrapBlueAvg").innerHTML = (wrapBlueMoveAvg).toFixed(2);
document.getElementById("smartBlueAvg").innerHTML = (smartBlueMoveAvg).toFixed(2);

drawMultSeries();

}// End updateResults()

/* resetGame()
// Purpose: This function resets the starting variables to their default values
// Inputs: none
// Outputs: none
*/
function resetGame(){
numRows = 10;
numCols = 10;
runSpeed = 250;
redPosX = 0;
redPosY = numRows-1;
bluePosX = numCols-1;
bluePosY = 0;
count = 0;
redCount = 0;
blueCount = 0;
redStomp = 0;
blueStomp = 0;
grid =	[
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
		]
max = 0;
min = 1000000;
average = 0;
direction = 0;
distance = 0;
}// End resetGame()

function resetAll(){

resetGame();

// Global Statistical Variables
wins = 0;
wrapWins = 0;
smartWins = 0;
normRedWins = 0;
normBlueWins = 0;
normRedMoves = 0;
normBlueMoves = 0;
normRedMoveAvg = 0;
normBlueMoveAvg = 0
normDraws = 0;
wrapRedWins = 0;
wrapBlueWins = 0;
wrapRedMoves = 0;
wrapBlueMoves = 0;
wrapRedMoveAvg = 0;
wrapBlueMoveAvg = 0
wrapDraws = 0;
smartRedWins = 0;
smartBlueWins = 0;
smartRedMoves = 0;
smartBlueMoves = 0;
smartRedMoveAvg = 0;
smartBlueMoveAvg = 0
smartDraws = 0;
normRedMoveArray = [];
normBlueMoveArray = [];
wrapRedMoveArray = [];
wrapBlueMoveArray = [];
smartRedMoveArray = [];
smartBlueMoveArray = [];

}

/* goHomeRed()
// Purpose: This function moves the red marker back to (0,numRows-1).
// 			This function is to be called when the blue marker	
//			ends its move on the red marker, sending it back to start.
// Inputs: none
// Outputs: none
*/
function goHomeRed(){
	redPosX = 0;
	redPosY = numRows-1;
}// End goHomeRed()

/* goHomeRed()
// Purpose: This function moves the blue marker back to (numCols-1,0).
// 			This function is to be called when the red marker	
//			ends its move on the blue marker, sending it back to start.
// Inputs: none
// Outputs: none
*/
function goHomeBlue(){
	bluePosX = numCols-1;
	bluePosY = 0;
}// End goHomeBlue()



function drawMultSeries() {
      data = google.visualization.arrayToDataTable([
        ['Average Moves', 'Red', 'Blue'],
        ['Normal Game', normRedMoveAvg, normBlueMoveAvg],
        ['Board Wrap Game', wrapRedMoveAvg, wrapBlueMoveAvg],
        ['Smart Move Game', smartRedMoveAvg, smartBlueMoveAvg]
      ]);

      options = {
        title: 'Average Moves Per Victory By Color and Game Mode',
        chartArea: {width: '50%'},
        hAxis: {
          title: 'Average Moves',
          minValue: 0
        },
        vAxis: {
          title: 'Game Mode'
        }
      };

      chart = new google.visualization.BarChart(document.getElementById('chart_div'));
      chart.draw(data, options);
    }

</script>

</body>
</html>
